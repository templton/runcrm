<h2>Как запустить систему и что сделано</h2>

- Склонировать проект
- Настроить подключение к БД в db.php

Выполнить консольные команды из корня проекта:

- composer install
- php yii migrate
- php yii stabdata

Команда php yii stabdata делает тестовое наполнение базы.

На текущий момент реализовано:

Перебор всех задач заданного курьера. Задачи посылаются на выполнение. В процессе выполнения задачи курьеру назначаются свобдные доставки из задачи и с курьера снимаются доставки для данного адреса.

Начал закладывать структуру для финансовых операций. Таблица account еще не добавлена.

<h2>Как запустить завершение таска</h2>

Метод API для запуска выполнения задач еще не реализован. Чтобы завершить все таски курьера необходимо выполнить два шага:

```
//Задаем курьера, таски которого нужно выполнить
$courier=Courier::findOne(1);
//Выполнить все таски курьера
$courier->executeTasks();
```

<h2>Раздел 1. Работа с клиентами и заказами</h2>

Клиент (Client) создает заказ (Order). Order - то список возможных перемещений товаров. Каждое перемещение - это Shipment. Один Order может содержать много Shipment.


Характеристики Shipment:

- Order - заказ, которому принадлежит Shipment

- title - Произвольное название

- status - состояние доставки: свободна, в работе, завершена

- price - сумма вознаграждения за доставку

- Location1 - точка отправления

- Location2 - точка назначения

- Courier - курьер, осуществляющий доставку


<h2>Раздел 2. Обработка заказов</h2>

Обработка заказов описывается в задачах - Task. 

Task может быть представлен различными классами, но каждый из этих классов должен реализовать внешний интерфейс для работы с Task-ом - TaskInterface

Task имеет следующие характеристики:

- Location - адрес, который обрабатывает данное задание

- Courier - курьер, которому назначено данное задание

- Processor

Задания могут быть разного типа и иметь разные подходы к обработке адреса. Например, может быть задание, суть которого посетить адрес и доставить документы о выполненной работе, или опросить клиента о качестве оказанной услуги и т.д.

Поэтому каждое задание необходимо обрабатывать по-своему. Но все реализации обработки заданий должны следовать общему интерфейсу - TaskProcessorInterface. 

Таким образом, все задания будут обрабатываться только с помощью публичных методов, описанных в TaskProcessorInterface.

В рамках данного технического задания будет рассмотрена только одна реализация данного интерфейса: ShipmentTaskProcessor

Реализация ShipmentTaskProcessor включает в себя следующие шаги:

- Первый курьер, прибывший на адрес, забирает все свободные shipments

- Курьер выдает все активные shipments, которые предназначены для данного адреса и которые данный курьер взял ранее (пункт 1 для предыдущих task)

- За все выданные shipments курьер получает на свой счет вознаграждение, сумма которого указана в выданном shipments

Класс ShipmentTaskProcessor так же гарантирует, что в один момент времени каждая задача для курьера может обрабатываться только одним процессом. То есть случаи, когда одновременно сработали два запроса на обработку задания и два раза была попытка списать один и тот же shipment и повторно зачислить вознаграждение - исключены.

Данная реализуется следующим образом.

Task содержит флаг in_process. Данный флаг может находиться в следующих стостояних:

“свободен” = 0

“в работе” = 1

“успешно выполнен” = 2

В методе execute класса ShipmentTaskProcessor проверяем значение данного флага в рижиме эксклюзивной блокировки, то есть если какие-либо другие процессы обратятся в этот же момент к данной записи, то они будут ждать, пока завершится текущий процесс.  Если флаг равен 1, значит, запрос отправлен ошибочно, выкидываем исключение. Если флаг равен 0, то устанавливаем флаг в 1 и продолжаем выполнение. 

Связь Task и Shipments происходит по адресу. То есть ставим задачу посетить адрес и на этом адресе выбираем все доставки, у которых адрес (отправления или назначения) равен адресу в задании. Но непосредственно адреса не сравниваем. Сравниваться будут именно локации - Location. Другими словами, чтобы shipment соответствовал Task им должена быть назначена одина и та же локация, с одним и тем же id.

<h2>Раздел 3 - финансовые операции</h2>

За верхний уровень логики перевода денег внутри системы отвечает класс UserMoneyTransfer.

Каждый факт движения какой-то суммы фиксируется в таблице money_transaction

Блокировка двойного списания или зачисления средств гарантируется следующим механизмом. Таблица money_transaction содержит составной идентификатор transfer_key, которым характеризуется каждый тип транзакции. 

Например, для зачисления суммы из shipment на счет courier ключ формируется из следующих параметров: shipment_id, ammount. Таким образом, в любом момент времени можно получить транзакцию, по которой была оплата услуг курьера по данной доставке.

transfer_key является уникальным ключем и в таблице не может быть двух одинаковых записей с таким ключем. Перед началом операции производится попытка записи в таблицу транзакции. Если запись прошла успешно, то есть такого ключа еще нет в таблице, то транзакция продолжается, иначе прерывается. Данная запись транзации так же содержит флаг in_process: 0 - завершена, 1 - в работе. Новая запись вставляется с флагом 1.

Публичные методы для операций со счетами пользователей описаны в интерфейсе MoneyTransactionInterfase. В рамках реализации данного технического задания за реализацию MoneyTransactionInterfase отвечает класс MoneyTransaction. Можно реализовать любой другой другой класс, описывающий методы данного интерфейса, в котором, например, будет применен другой режим блокировки или какие-то иные проверки. Но интерфейс должен остаться тот же самый.

Класс UserMoneyTransfer запрашивает создание транзакции через MoneyTransactionInterfase. Входными параметрами для создания транзакции является набор параметров для уникального ключа transfer_key. Открывается транзакция в mysql. Если запись с уникальным ключем была успешно внесена в таблицу, то UserMoneyTransfer проводит финансовую операцию и отправляет команду на завершение транзакции. Метод из MoneyTransactionInterfase проводит завершение транзакции, а именно: снова выбирает запись транзакции по ключу transer_key с установкой экслюзивной блокировки. Если оказывается так, что данная запись в поле in_process содержит 0, значит уже прошла операция другая операция зачисления по данной транзакции и все изменения откатываются, в том числе откатится и операция, которая проводилась. А если in_process равен 1, значит транзакция по данному ключу еще в работе, обновляем запись, устанавливая необходимые параметры транзакции и флаг in_process=0. Отправляем commit на завершение общей транзакции.

<h2>Само задание:</h2>

В системе существуют следующие сущности и связи между ними:

1 Client (у него есть имя)

2 У клиента есть Order (у него есть номер)

3 У Заказа есть Location (у него есть адрес)

4 Есть Shipment (у него есть стоимость). Он может быть забран на одном адресе, и выдан на другом адресе

5 Есть User (у него есть имя и денежный счет)

6 User-у назначается Task посетить Location. При выполнении Task происходит получение всех Shipment, которые на этом адресе выдаются, и выдача всех Shipment, которые на этом адресе доставляются (на основании связей, описанных в пункте 4). Можно выдать только Shipment, который уже был забран этим User.

7 Когда Shipment выдается, на счет User приходит стоимость Shipment.

8 User может перечислить произвольную часть имеющихся на его счету денег другому User. Деньги уходят с его счета и приходят на счет получателя

Пример: курьер передает деньги кассиру. 

9 Факт прихода/ухода денег фиксируется Transaction, которая содержит информацию кому, сколько денег и текущее количество денег на счету было на тот момент, аналогично банковской выписке (т.е. по каждому пользователю  возможно проследить движение средств)

Реализовать: 

Структуру базы под описанные связи, тестовые fixture, CRUD не требуется

1.REST метод для завершения Task

Деньги зачисляются на счет назначенного User

Невозможно завершить задачу по выдаче Shipment, если он еще не был получен этим же User.


2. REST метод для перевода денег между 2мя User

Невозможность списать больше, чем есть на счету 

Невозможность двойного получения

Невозможность двойного списания денег
